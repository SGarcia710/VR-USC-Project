<!DOCTYPE html>
<html lang="es">

<head>
  <title>Selector de Atomos</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="./src/three.js"></script>
  <script src="./src/ControllerPickHelper.js"></script>
  <script src="./src/DragControls.js"></script>
  <script src="./src/Reflector.js"></script>
  <script src="./src/Refractor.js"></script>
  <script src="./src/Logic.js"></script>
  <script src="./src/datguivr.js"></script>
</head>

<body>
  <p id="pregunta"></p>
  <p id="causa"></p>

  <script type="module">
    import { SceneUtils } from "https://threejsfundamentals.org/threejs/resources/threejs/r110/examples/jsm/utils/SceneUtils.js";
    import * as WEBVR from "./src/WebVR.js";
    import * as Water from "./src/Water2.js";

    const RADIUS = 0.15;
    const PAREDESCUADRO = 4;
    var clock = new THREE.Clock();
    var normal = new THREE.Vector3();
    var relativeVelocity = new THREE.Vector3();
    var logica = new Logic();
    var container;
    var camera, scene, renderer, agua, textureLoader;
    var room;
    var isMouseDown = false;
    var objetos = [];
    var startColor;
    var cont;
    var velX, velY, velZ;
    var pickHelper;
    var gui;

    init();
    animate();

    function init() {
      document.getElementById("pregunta").innerHTML = logica.pregunta;
      container = document.createElement("div");
      document.body.appendChild(container);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x505050);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 10);
      scene.add(camera);
      textureLoader = new THREE.TextureLoader();

      //Fog
      scene.fog = new THREE.FogExp2(0xefd1b5, 0.2);

      //Suelo
      var pisoMallaG = new THREE.PlaneBufferGeometry(10, 10, 10, 10);
      var pisoMallaM = new THREE.MeshBasicMaterial({ color: 0x0000, wireframe: true });
      var pisoMalla = new THREE.Mesh(pisoMallaG, pisoMallaM);
      pisoMalla.rotation.x = Math.PI * -0.5;
      pisoMalla.position.x = 0;
      scene.add(pisoMalla);

      //Skybox
      var cubeTextureLoader = new THREE.CubeTextureLoader();
      cubeTextureLoader.setPath("./assets/textures/");
      var cubeTexture = cubeTextureLoader.load([
        "px.jpg",
        "nx.jpg",
        "py.jpg",
        "ny.jpg",
        "pz.jpg",
        "nz.jpg"
      ]);
      scene.background = cubeTexture;

      //Agua
      var aguaGeometry = new THREE.PlaneBufferGeometry(40, 40);
      var flowMap = textureLoader.load("./assets/textures/water/Water_1_M_Flow.jpg");
      agua = new THREE.Water(aguaGeometry, { scale: 2, textureWidth: 1024, textureHeight: 1024, flowMap: flowMap });
      agua.position.y = 0.5;
      agua.rotation.x = Math.PI * -0.5;
      scene.add(agua);

      scene.add(new THREE.HemisphereLight(0x606060, 0x404040));
      var light = new THREE.DirectionalLight(0xffffff);
      light.position.set(1, 1, 1).normalize();
      scene.add(light);

      var colors = [];
      colors.push(0xAA88B2); // Hidrogreno
      colors.push(0x88A2B2); // Oxigeno
      colors.push(0x7EDC88); // Carbono
      colors.push(0x7edc88); // Sodio
      colors.push(0xf4fa58); // Cloro
      colors.push(0x7edcd4); // Silicio

      var geometry = new THREE.IcosahedronGeometry(RADIUS, 2);
      for (var i = 0, j = 0; i < 300; i++ , j++) {
        if (j == 6) j = 0;
        var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: colors[j] }));
        object.position.x = Math.random() * 4 - 2;
        object.position.y = Math.random() * 20 + 1;
        object.position.z = Math.random() * 4 - 2;
        object.userData.velocity = new THREE.Vector3();
        object.userData.velocity.x = Math.random() * 0.01 - 0.005;
        object.userData.velocity.y = Math.random() * 0.01 - 0.005;
        object.userData.velocity.z = Math.random() * 0.01 - 0.005;
        object.castShadow = true;
        object.receiveShadow = true;
        objetos.push(object);
        scene.add(object);
      }
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.vr.enabled = true;
      container.appendChild(renderer.domElement);

      /*
      renderer.domElement.addEventListener("mousedown", onMouseDown, false);
      renderer.domElement.addEventListener("mouseup", onMouseUp, false);
      renderer.domElement.addEventListener("touchstart", onMouseDown, false);
      renderer.domElement.addEventListener("touchend", onMouseUp, false);
      */

      window.addEventListener("resize", onWindowResize, false);

      /*
      var controls = new THREE.DragControls(objetos, camera, renderer.domElement);
      controls.addEventListener("dragstart", dragStarCallback);
      controls.addEventListener("dragend", dragEndCallback);
      */

      document.body.appendChild(THREE.WEBVR.createButton(renderer));

      const controllerToSelection = new Map();
      pickHelper = new ControllerPickHelper(scene, renderer, objetos);

      pickHelper.addEventListener("selectstart", event => {
        const { controller, selectedObject } = event;
        startColor = selectedObject.material.color.getHex();

        velX = selectedObject.userData.velocity.x;
        velY = selectedObject.userData.velocity.y;
        velZ = selectedObject.userData.velocity.z;
        selectedObject.userData.velocity.x = 0;
        selectedObject.userData.velocity.y = 0;
        selectedObject.userData.velocity.z = 0;

        const existingSelection = controllerToSelection.get(controller);
        if (!existingSelection) {
          onMouseDown();
          controllerToSelection.set(controller, { object: selectedObject, parent: selectedObject.parent });
          SceneUtils.detach(selectedObject, selectedObject.parent, scene);
          SceneUtils.attach(selectedObject, scene, controller);

        //Suelo
        var pisoMallaG = new THREE.PlaneBufferGeometry(10, 10, 10, 10);
        var pisoMallaM = new THREE.MeshBasicMaterial({
          color: 0x0000,
          wireframe: true
        });
        var pisoMalla = new THREE.Mesh(pisoMallaG, pisoMallaM);
        pisoMalla.rotation.x = Math.PI * -0.5;
        pisoMalla.position.x = 0;
        scene.add(pisoMalla);

        //Skybox
        var cubeTextureLoader = new THREE.CubeTextureLoader();
        cubeTextureLoader.setPath("./assets/textures/");
        var cubeTexture = cubeTextureLoader.load([
          "px.jpg",
          "nx.jpg",
          "py.jpg",
          "ny.jpg",
          "pz.jpg",
          "nz.jpg"
        ]);
        scene.background = cubeTexture;

        //Agua
        var aguaGeometry = new THREE.PlaneBufferGeometry(40, 40);
        var flowMap = textureLoader.load(
          "./assets/textures/water/Water_1_M_Flow.jpg"
        );
        agua = new THREE.Water(aguaGeometry, {
          scale: 2,
          textureWidth: 1024,
          textureHeight: 1024,
          flowMap: flowMap
        });
        agua.position.y = 0.5;
        agua.rotation.x = Math.PI * -0.5;
        scene.add(agua);

        scene.add(new THREE.HemisphereLight(0x606060, 0x404040));
        var light = new THREE.DirectionalLight(0xffffff);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        var colors = [];
        colors.push(0xAA88B2); // Hidrogreno
        colors.push(0x88A2B2); // Oxigeno
        colors.push(0x7EDC88); // Carbono
        colors.push(0x7edc88); // Sodio
        colors.push(0xf4fa58); // Cloro
        colors.push(0x7edcd4); // Silicio

        var geometry = new THREE.IcosahedronGeometry(RADIUS, 3);
        for (var i = 0, j = 0; i < 300; i++, j++) {
          if (j == 6) j = 0;
          var object = new THREE.Mesh(
            geometry,
            new THREE.MeshLambertMaterial({ color: colors[j] })
          );
          object.position.x = Math.random() * 4 - 2;
          object.position.y = Math.random() * 20 + 1;
          object.position.z = Math.random() * 4 - 2;
          object.userData.velocity = new THREE.Vector3();
          object.userData.velocity.x = Math.random() * 0.01 - 0.005;
          object.userData.velocity.y = Math.random() * 0.01 - 0.005;
          object.userData.velocity.z = Math.random() * 0.01 - 0.005;
          object.castShadow = true;
          object.receiveShadow = true;
          objetos.push(object);
          scene.add(object);
        }
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.vr.enabled = true;
        container.appendChild(renderer.domElement);
        //renderer.domElement.addEventListener("mousedown", onMouseDown, false);
        //renderer.domElement.addEventListener("mouseup", onMouseUp, false);
        //renderer.domElement.addEventListener("touchstart", onMouseDown, false);
        //renderer.domElement.addEventListener("touchend", onMouseUp, false);
        window.addEventListener("resize", onWindowResize, false);

        /* var controls = new THREE.DragControls(
                objetos,
                camera,
                renderer.domElement
              );
              controls.addEventListener("dragstart", dragStarCallback);
              controls.addEventListener("dragend", dragEndCallback);*/

        document.body.appendChild(THREE.WEBVR.createButton(renderer));

        class ControllerPickHelper extends THREE.EventDispatcher {
          constructor(scene) {
            super();
            console.log("ENTRE A LA CLASE");
            this.raycaster = new THREE.Raycaster();
            this.objectToColorMap = new Map();
            this.controllerToObjectMap = new Map();
            this.tempMatrix = new THREE.Matrix4();

            const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(0, 0, -1)
            ]);

            this.controllers = [];

            const selectListener = event => {
              const controller = event.target;
              const selectedObject = this.controllerToObjectMap.get(
                event.target
              );
              if (selectedObject) {
                this.dispatchEvent({
                  type: event.type,
                  controller,
                  selectedObject
                });
              }
            };

            const endListener = event => {
              const controller = event.target;
              this.dispatchEvent({ type: event.type, controller });
            };

            for (let i = 0; i < 2; ++i) {
              const controller = renderer.vr.getController(i);
              controller.addEventListener("select", selectListener);
              controller.addEventListener("selectstart", selectListener);
              controller.addEventListener("selectend", endListener);
              scene.add(controller);

              const line = new THREE.Line(pointerGeometry);
              line.scale.z = 5;
              controller.add(line);
              this.controllers.push({ controller, line });
            }
          }
          reset() {
            // restore the colors
            this.objectToColorMap.forEach((color, object) => {
              object.material.emissive.setHex(color);
            });
            this.objectToColorMap.clear();
            this.controllerToObjectMap.clear();
          }
          update(scene, time) {
            this.reset();
            for (const { controller, line } of this.controllers) {
              // cast a ray through the from the controller
              this.tempMatrix
                .identity()
                .extractRotation(controller.matrixWorld);
              this.raycaster.ray.origin.setFromMatrixPosition(
                controller.matrixWorld
              );
              this.raycaster.ray.direction
                .set(0, 0, -1)
                .applyMatrix4(this.tempMatrix);
              // get the list of objects the ray intersected
              const intersections = this.raycaster.intersectObjects(objetos);
              if (intersections.length) {
                const intersection = intersections[0];
                // make the line touch the object
                line.scale.z = intersection.distance;
                // pick the first object. It's the closest one
                const pickedObject = intersection.object;
                // save which object this controller picked
                this.controllerToObjectMap.set(controller, pickedObject);
                // highlight the object if we haven't already
                if (this.objectToColorMap.get(pickedObject) === undefined) {
                  // save its color
                  this.objectToColorMap.set(
                    pickedObject,
                    pickedObject.material.emissive.getHex()
                  );
                  // set its emissive color to flashing red/yellow
                  pickedObject.material.emissive.setHex(
                    (time * 8) % 2 > 1 ? 0xff2000 : 0xff0000
                  );
                }
              } else {
                line.scale.z = 5;
              }
            }
          }

        }

        var aux = logica.cambioColor(startColor);

        var aux2 = logica.game(startColor);

        var aux2 = logica.pregunta;
        
				scene.remove(gui);

				// crear el gui
				gui = dat.GUIVR.create(aux +" "+ aux2);
        
      
				gui.position.x = 0;
				gui.position.y = 2;
				gui.position.z = -1.5;
				
				scene.add(gui);
				dat.GUIVR.enableMouse( camera );

        });

        pickHelper.addEventListener("selectend", event => {
          const { controller } = event;
          const selection = controllerToSelection.get(controller);
          if (selection) {
            onMouseUp();
            selection.object.userData.velocity.x = velX / 2;
            selection.object.userData.velocity.y = velY / 2;
            selection.object.userData.velocity.z = velZ / 2;
            controllerToSelection.delete(controller);
            SceneUtils.detach(selection.object, controller, scene);
            SceneUtils.attach(selection.object, scene, selection.parent);
          }
              document.getElementById("causa").innerHTML = logica.game(startColor);
              document.getElementById("pregunta").innerHTML = logica.pregunta;

        scene.remove(gui);

        // crear el gui
        gui = dat.GUIVR.create(aux + " " + aux2);

        gui.position.x = 0;
        gui.position.y = 2;
        gui.position.z = -1.5;

        scene.add(gui);
        dat.GUIVR.enableMouse(camera);
      });

      pickHelper.addEventListener("selectend", event => {
        const { controller } = event;
        const selection = controllerToSelection.get(controller);
        if (selection) {
          onMouseUp();
          selection.object.userData.velocity.x = velX / 2;
          selection.object.userData.velocity.y = velY / 2;
          selection.object.userData.velocity.z = velZ / 2;
          controllerToSelection.delete(controller);
          SceneUtils.detach(selection.object, controller, scene);
          SceneUtils.attach(selection.object, scene, selection.parent);
        }
        document.getElementById("causa").innerHTML = logica.game(startColor);
        document.getElementById("pregunta").innerHTML = logica.pregunta;
      });

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }
    }

    /*
    function dragStarCallback(event) {
      startColor = event.object.material.color.getHex();
      velX = event.object.userData.velocity.x;
      velY = event.object.userData.velocity.y;
      velZ = event.object.userData.velocity.z;
      event.object.userData.velocity.x = 0;
      event.object.userData.velocity.y = 0;
      event.object.userData.velocity.z = 0;
      event.object.material.color.setHex(0x000000);
    }

    function dragEndCallback(event) {
      document.getElementById("causa").innerHTML = logica.game(startColor);
      document.getElementById("pregunta").innerHTML = logica.pregunta;
      event.object.userData.velocity.x = velX / 2;
      event.object.userData.velocity.y = velY / 2;
      event.object.userData.velocity.z = velZ / 2;
      event.object.material.color.setHex(startColor);
    }
    */

    function onMouseDown() {
      cont = 0;
      isMouseDown = true;
    }

    function onMouseUp() {
      cont = 0;
      isMouseDown = false;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render() {
      var delta = clock.getDelta() * 60;
      if (cont == 300) cont = 0;

      if (isMouseDown === true && cont < 300) {
        var cube = objetos[cont];
        objetos.pop(0);
        cube.position.applyQuaternion(camera.quaternion);
        cube.userData.velocity.x = (Math.random() - 0.5) * 0.02 * delta;
        cube.userData.velocity.y = (Math.random() - 0.5) * 0.02 * delta;
        cube.userData.velocity.z = (Math.random() * 0.01 - 0.05) * delta;
        cube.userData.velocity.applyQuaternion(camera.quaternion);
        objetos.push(cube);
        cont++;
      }

      objetos.forEach(element => {
        var cube = element;
        cube.userData.velocity.multiplyScalar(1 - 0.001 * delta);
        cube.position.add(cube.userData.velocity);
        if (cube.position.x < -PAREDESCUADRO || cube.position.x > PAREDESCUADRO) {
          cube.position.x = THREE.Math.clamp(cube.position.x, -PAREDESCUADRO, PAREDESCUADRO);
          cube.userData.velocity.x = -cube.userData.velocity.x;
        }
        if (cube.position.y < 0 || cube.position.y > PAREDESCUADRO) {
          cube.position.y = THREE.Math.clamp(cube.position.y, 0, PAREDESCUADRO);
          cube.userData.velocity.y = -cube.userData.velocity.y;
        }
        if (cube.position.z < -PAREDESCUADRO || cube.position.z > PAREDESCUADRO) {
          cube.position.z = THREE.Math.clamp(cube.position.z, -PAREDESCUADRO, PAREDESCUADRO);
          cube.userData.velocity.z = -cube.userData.velocity.z;
        }
        cube.rotation.x += cube.userData.velocity.x * 2 * delta;
        cube.rotation.y += cube.userData.velocity.y * 2 * delta;
        cube.rotation.z += cube.userData.velocity.z * 2 * delta;

        objetos.forEach(element2 => {
          var object2 = element2;
          normal.copy(cube.position).sub(object2.position);
          var distance = normal.length();
          if (distance < 2 * RADIUS) {
            normal.multiplyScalar(0.5 * distance - RADIUS);
            cube.position.sub(normal);
            object2.position.add(normal);
            normal.normalize();
            relativeVelocity.copy(cube.userData.velocity).sub(object2.userData.velocity);
            normal = normal.multiplyScalar(relativeVelocity.dot(normal));
            cube.userData.velocity.sub(normal);
            object2.userData.velocity.add(normal);
          }

          //cube.rotation.x += cube.userData.velocity.x * 2 * delta;
          //cube.rotation.y += cube.userData.velocity.y * 2 * delta;
          //cube.rotation.z += cube.userData.velocity.z * 2 * delta;

          objetos.forEach(element2 => {
            var object2 = element2;
            normal.copy(cube.position).sub(object2.position);
            var distance = normal.length();
            if (distance < 2 * RADIUS) {
              normal.multiplyScalar(0.5 * distance - RADIUS);
              cube.position.sub(normal);
              object2.position.add(normal);
              normal.normalize();
              relativeVelocity
                .copy(cube.userData.velocity)
                .sub(object2.userData.velocity);
              normal = normal.multiplyScalar(relativeVelocity.dot(normal));
              cube.userData.velocity.sub(normal);
              object2.userData.velocity.add(normal);
            }
          });
        });
      });


      pickHelper.update(scene, delta, objetos);
      renderer.render(scene, camera);
    }
  </script>
</body>
        let ndx = 0;
        for (const mesh of objetos) {
          const speed = 1 + ndx * 0.1;
          const rot = delta * speed;
          //mesh.rotation.x = rot;
          //mesh.rotation.y = rot;
          ++ndx;
        }

</html>